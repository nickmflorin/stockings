generator client {
  provider        = "prisma-client-js"
  previewFeatures = []
  output          = "../model/generated"
}

datasource db {
  provider  = "postgresql"
  url       = env("POSTGRES_PRISMA_URL") // Uses Connection Pooling
  directUrl = env("POSTGRES_URL_NON_POOLING") // Uses a Direct Connection
}

model User {
  id                                String                      @id @default(uuid()) @db.Uuid
  clerkId                           String                      @unique
  firstName                         String
  lastName                          String
  profileImageUrl                   String?
  emailAddress                      String
  createdAt                         DateTime                    @default(now())
  updatedAt                         DateTime                    @updatedAt
  createdProducts                   Product[]                   @relation("createdProducts")
  updatedProducts                   Product[]                   @relation("updatedProducts")
  createdProductRecords             ProductRecord[]             @relation("createdProductRecords")
  updatedProductRecords             ProductRecord[]             @relation("updatedProductRecords")
  productNotificationConfigs        ProductNotificationConfig[] @relation("productNotificationConfigs")
  createdProductNotificationConfigs ProductNotificationConfig[] @relation("createdProductNotificationConfigs")
  updatedProductNotificationConfigs ProductNotificationConfig[] @relation("updatedProductNotificationConfigs")
  createdPriceChangeEventConfigs    PriceChangeEventConfig[]    @relation("createdPriceChangeEventConfigs")
  updatedPriceChangeEventConfigs    PriceChangeEventConfig[]    @relation("updatedPriceChangeEventConfigs")
  createdStatusChangeEventConfigs   StatusChangeEventConfig[]   @relation("createdStatusChangeEventConfigs")
  updatedStatusChangeEventConfigs   StatusChangeEventConfig[]   @relation("updatedStatusChangeEventConfigs")
}

enum ElementAttribute {
  HREF
  SRC
  VALUE
  DATA_GA_PRODUCT_NAME
}

enum ScrapingErrorCode {
  MISSING_ATTRIBUTE
  INVALID_ATTRIBUTE
  MISSING_TEXT
  INVALID_TEXT
  NONUNIQUE_TEXT
  MISSING_ELEMENT
  NONUNIQUE_ELEMENT
  HTTP_NETWORK
  HTTP_CLIENT
  HTTP_SERIALIZATION
}

enum ProductRecordDataField {
  PRICE
  RAW_PRICE
  STATUS
}

model HttpNetworkErrorData {
  id  String @id @default(uuid()) @db.Uuid
  url String
}

model HttpSerializationErrorData {
  id  String @id @default(uuid()) @db.Uuid
  url String
}

model HttpClientErrorData {
  id     String @id @default(uuid()) @db.Uuid
  url    String
  status Int
}

model MissingAttributeErrorData {
  id         String           @id @default(uuid()) @db.Uuid
  attribute  ElementAttribute
  parentHtml String?
}

model InvalidAttributeErrorData {
  id         String           @id @default(uuid()) @db.Uuid
  attribute  ElementAttribute
  parentHtml String?
  value      String
}

model InvalidTextErrorData {
  id         String  @id @default(uuid()) @db.Uuid
  parentHtml String?
  value      String
}

model MissingTextErrorData {
  id         String  @id @default(uuid()) @db.Uuid
  parentHtml String?
}

model NonUniqueTextErrorData {
  id         String  @id @default(uuid()) @db.Uuid
  parentHtml String?
}

model MissingElementErrorData {
  id         String  @id @default(uuid()) @db.Uuid
  parentHtml String?
  selector   String
}

model NonUniqueElementErrorData {
  id         String  @id @default(uuid()) @db.Uuid
  parentHtml String?
  selector   String
}

model ProductRecordError {
  id        String                 @id @default(uuid()) @db.Uuid
  errorId   String                 @unique @db.Uuid
  errorCode ScrapingErrorCode
  record    ProductRecord          @relation("errors", fields: [recordId], references: [id])
  recordId  String                 @unique @db.Uuid
  field     ProductRecordDataField
  message   String
}

enum ProductStatus {
  OUT_OF_STOCK
  IN_STOCK
  AVAILABLE_FOR_BACKORDER
  NOT_LISTED
}

model ProductRecord {
  id                    String                   @id @default(uuid()) @db.Uuid
  timestamp             DateTime                 @default(now())
  createdBy             User                     @relation("createdProductRecords", fields: [createdById], references: [id])
  createdById           String                   @db.Uuid
  createdAt             DateTime                 @default(now())
  updatedBy             User                     @relation("updatedProductRecords", fields: [updatedById], references: [id])
  updatedById           String                   @db.Uuid
  updatedAt             DateTime                 @updatedAt
  product               Product                  @relation("records", fields: [productId], references: [id])
  productId             String                   @db.Uuid
  price                 Float?
  rawPrice              String?
  status                ProductStatus?
  wasManuallyCreated    Boolean                  @default(false)
  manuallyChangedFields ProductRecordDataField[] @default([])
  errors                ProductRecordError[]     @relation("errors")
}

enum ProductCategory {
  HandTools
}

enum ProductSubCategory {
  HandPlanes
  Saws
  Chisels
  Spokeshaves
  GreenWoodworking
  AccessoryTools
}

model Product {
  id                  String                      @id @default(uuid()) @db.Uuid
  createdAt           DateTime                    @default(now())
  createdBy           User                        @relation("createdProducts", fields: [createdById], references: [id])
  createdById         String                      @db.Uuid
  updatedAt           DateTime                    @updatedAt
  updatedBy           User                        @relation("updatedProducts", fields: [updatedById], references: [id])
  updatedById         String                      @db.Uuid
  name                String?
  slug                String                      @unique
  code                String?
  imageSrc            String?
  records             ProductRecord[]             @relation("records")
  status              ProductStatus?
  statusRecordedAt    DateTime?
  price               Float?
  priceRecordedAt     DateTime?
  category            ProductCategory
  subCategories       ProductSubCategory[]
  notificationConfigs ProductNotificationConfig[] @relation("notificationConfigs")
}

enum PriceChangeEventConfigType {
  PRICE_INCREASE
  PRICE_DECREASE
}

model PriceChangeEventConfig {
  id                          String                       @id @default(uuid()) @db.Uuid
  createdAt                   DateTime                     @default(now())
  createdBy                   User                         @relation("createdPriceChangeEventConfigs", fields: [createdById], references: [id])
  createdById                 String                       @db.Uuid
  updatedAt                   DateTime                     @updatedAt
  updatedBy                   User                         @relation("updatedPriceChangeEventConfigs", fields: [updatedById], references: [id])
  updatedById                 String                       @db.Uuid
  productNotificationConfig   ProductNotificationConfig    @relation("priceChangeEventConfigs", fields: [productNotificationConfigId], references: [id])
  productNotificationConfigId String                       @db.Uuid
  configType                  PriceChangeEventConfigType[] @default([PRICE_INCREASE, PRICE_DECREASE])
}

model StatusChangeEventConfig {
  id                          String                    @id @default(uuid()) @db.Uuid
  createdAt                   DateTime                  @default(now())
  createdBy                   User                      @relation("createdStatusChangeEventConfigs", fields: [createdById], references: [id])
  createdById                 String                    @db.Uuid
  updatedAt                   DateTime                  @updatedAt
  updatedBy                   User                      @relation("updatedStatusChangeEventConfigs", fields: [updatedById], references: [id])
  updatedById                 String                    @db.Uuid
  productNotificationConfig   ProductNotificationConfig @relation("statusChangeEventConfigs", fields: [productNotificationConfigId], references: [id])
  productNotificationConfigId String                    @db.Uuid
  statuses                    ProductStatus[]
}

model ProductNotificationConfig {
  id                       String                    @id @default(uuid()) @db.Uuid
  createdAt                DateTime                  @default(now())
  createdBy                User                      @relation("createdProductNotificationConfigs", fields: [createdById], references: [id])
  createdById              String                    @db.Uuid
  updatedAt                DateTime                  @updatedAt
  updatedBy                User                      @relation("updatedProductNotificationConfigs", fields: [updatedById], references: [id])
  updatedById              String                    @db.Uuid
  product                  Product                   @relation("notificationConfigs", fields: [productId], references: [id])
  productId                String                    @db.Uuid
  // For now, we will keep the user that should receive the notification separate from the user that
  // created it - even though, for all intents and purposes, they will be the same.  This is just
  // to allow some flexibility in the future.
  user                     User                      @relation("productNotificationConfigs", fields: [userId], references: [id])
  userId                   String                    @db.Uuid
  priceChangeEventConfigs  PriceChangeEventConfig[]  @relation("priceChangeEventConfigs")
  statusChangeEventConfigs StatusChangeEventConfig[] @relation("statusChangeEventConfigs")
}
