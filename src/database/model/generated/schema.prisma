//////////////////////////////////////////////////////////////////////////////////////////////
// DO NOT MODIFY THIS FILE                                                                  //
// This file is automatically generated by ZenStack CLI and should not be manually updated. //
//////////////////////////////////////////////////////////////////////////////////////////////

datasource db {
  provider  = "postgresql"
  url       = env("POSTGRES_PRISMA_URL")
  directUrl = env("POSTGRES_URL_NON_POOLING")
}

generator client {
  provider = "prisma-client-js"
  output   = "../model/generated"
}

enum ElementAttribute {
  HREF
  SRC
  VALUE
  DATA_GA_PRODUCT_NAME
}

enum ScrapingErrorCode {
  MISSING_ATTRIBUTE
  INVALID_ATTRIBUTE
  MISSING_TEXT
  INVALID_TEXT
  NONUNIQUE_TEXT
  MISSING_ELEMENT
  NONUNIQUE_ELEMENT
  HTTP_NETWORK
  HTTP_CLIENT
  HTTP_SERIALIZATION
}

enum ProductRecordDataField {
  PRICE
  RAW_PRICE
  STATUS
}

enum ProductStatus {
  OutOfStock
  InStock
  AvailableForBackorder
  NotListed
}

enum ProductCategory {
  HandTools
}

enum ProductSubCategory {
  HandPlanes
  Saws
  Chisels
  Spokeshaves
  GreenWoodworking
  AccessoryTools
}

enum PriceChangeCondition {
  PriceIncrease
  PriceDecrease
}

enum ProductSubscriptionType {
  PriceChangeSubscription
  StatusChangeSubscription
}

enum ProductNotificationType {
  PriceChangeNotification
  StatusChangeNotification
}

enum NotificationState {
  Pending
  Sent
  Failed
}

enum NotificationMedium {
  Email
  SMS
  Application
}

model User {
  id                          String                @id() @default(uuid()) @db.Uuid()
  clerkId                     String                @unique()
  firstName                   String
  lastName                    String
  profileImageUrl             String?
  emailAddress                String                @unique()
  createdAt                   DateTime              @default(now())
  updatedAt                   DateTime              @updatedAt()
  createdProducts             Product[]             @relation("createdProducts")
  updatedProducts             Product[]             @relation("updatedProducts")
  createdProductRecords       ProductRecord[]       @relation("createdProductRecords")
  updatedProductRecords       ProductRecord[]       @relation("updatedProductRecords")
  createdProductSubscriptions ProductSubscription[] @relation("createdProductSubscriptions")
  updatedProductSubscriptions ProductSubscription[] @relation("updatedProductSubscriptions")
  productSubscriptions        ProductSubscription[] @relation("productSubscriptions")
  createdProductNotifications ProductNotification[] @relation("createdProductNotifications")
  updatedProductNotifications ProductNotification[] @relation("updatedProductNotifications")
  notifications               ProductNotification[] @relation("notifications")
}

model HttpNetworkErrorData {
  id  String @id() @default(uuid()) @db.Uuid()
  url String
}

model HttpSerializationErrorData {
  id  String @id() @default(uuid()) @db.Uuid()
  url String
}

model HttpClientErrorData {
  id     String @id() @default(uuid()) @db.Uuid()
  url    String
  status Int
}

model MissingAttributeErrorData {
  id         String           @id() @default(uuid()) @db.Uuid()
  attribute  ElementAttribute
  parentHtml String?
}

model InvalidAttributeErrorData {
  id         String           @id() @default(uuid()) @db.Uuid()
  attribute  ElementAttribute
  parentHtml String?
  value      String
}

model InvalidTextErrorData {
  id         String  @id() @default(uuid()) @db.Uuid()
  parentHtml String?
  value      String
}

model MissingTextErrorData {
  id         String  @id() @default(uuid()) @db.Uuid()
  parentHtml String?
}

model NonUniqueTextErrorData {
  id         String  @id() @default(uuid()) @db.Uuid()
  parentHtml String?
}

model MissingElementErrorData {
  id         String  @id() @default(uuid()) @db.Uuid()
  parentHtml String?
  selector   String
}

model NonUniqueElementErrorData {
  id         String  @id() @default(uuid()) @db.Uuid()
  parentHtml String?
  selector   String
}

model ProductRecordError {
  id        String                 @id() @default(uuid()) @db.Uuid()
  errorId   String                 @unique() @db.Uuid()
  errorCode ScrapingErrorCode
  record    ProductRecord          @relation("errors", fields: [recordId], references: [id])
  recordId  String                 @unique() @db.Uuid()
  field     ProductRecordDataField
  message   String
}

model ProductRecord {
  id                    String                   @id() @default(uuid()) @db.Uuid()
  createdAt             DateTime                 @default(now())
  updatedAt             DateTime                 @updatedAt()
  createdById           String                   @db.Uuid()
  updatedById           String                   @db.Uuid()
  timestamp             DateTime                 @default(now())
  createdBy             User                     @relation("createdProductRecords", fields: [createdById], references: [id])
  updatedBy             User                     @relation("updatedProductRecords", fields: [updatedById], references: [id])
  product               Product                  @relation("records", fields: [productId], references: [id])
  productId             String                   @db.Uuid()
  price                 Float?
  rawPrice              String?
  status                ProductStatus?
  wasManuallyCreated    Boolean                  @default(false)
  manuallyChangedFields ProductRecordDataField[] @default([])
  errors                ProductRecordError[]     @relation("errors")
  notifications         ProductNotification[]    @relation("notifications")
}

model Product {
  id                  String                @id() @default(uuid()) @db.Uuid()
  createdAt           DateTime              @default(now())
  updatedAt           DateTime              @updatedAt()
  createdById         String                @db.Uuid()
  updatedById         String                @db.Uuid()
  createdBy           User                  @relation("createdProducts", fields: [createdById], references: [id])
  updatedBy           User                  @relation("updatedProducts", fields: [updatedById], references: [id])
  name                String?
  descriptions        String[]
  slug                String                @unique()
  code                String?
  imageSrc            String?
  records             ProductRecord[]       @relation("records")
  status              ProductStatus?
  statusLastUpdatedAt DateTime?
  statusAsOf          DateTime?
  price               Float?
  priceLastUpdatedAt  DateTime?
  priceAsOf           DateTime?
  category            ProductCategory
  subCategories       ProductSubCategory[]
  subscriptions       ProductSubscription[] @relation("subscriptions")
  notifications       ProductNotification[] @relation("notifications")
}

/// @@delegate(subscriptionType)
model ProductSubscription {
  id                                    String                    @id() @default(uuid()) @db.Uuid()
  createdAt                             DateTime                  @default(now())
  updatedAt                             DateTime                  @updatedAt()
  createdById                           String                    @db.Uuid()
  updatedById                           String                    @db.Uuid()
  createdBy                             User                      @relation("createdProductSubscriptions", fields: [createdById], references: [id])
  updatedBy                             User                      @relation("updatedProductSubscriptions", fields: [updatedById], references: [id])
  subscriptionType                      ProductSubscriptionType
  userId                                String                    @db.Uuid()
  user                                  User                      @relation("productSubscriptions", fields: [userId], references: [id])
  product                               Product                   @relation("subscriptions", fields: [productId], references: [id])
  productId                             String                    @db.Uuid()
  enabled                               Boolean                   @default(true)
  notifications                         ProductNotification[]     @relation("notifications")
  mediums                               NotificationMedium[]      @default([Application])
  delegate_aux_statusChangeSubscription StatusChangeSubscription?
  delegate_aux_priceChangeSubscription  PriceChangeSubscription?

  @@unique([userId, productId, subscriptionType])
}

model StatusChangeSubscriptionCondition {
  id             String                   @id() @default(uuid()) @db.Uuid()
  createdAt      DateTime                 @default(now())
  updatedAt      DateTime                 @updatedAt()
  fromStatus     ProductStatus[]
  toStatus       ProductStatus[]
  subscription   StatusChangeSubscription @relation("conditions", fields: [subscriptionId], references: [id])
  subscriptionId String                   @db.Uuid()
}

model StatusChangeSubscription {
  id                               String                              @id() @default(uuid()) @db.Uuid()
  conditions                       StatusChangeSubscriptionCondition[] @relation("conditions")
  delegate_aux_productSubscription ProductSubscription                 @relation(fields: [id], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

model PriceChangeSubscription {
  id                               String                 @id() @default(uuid()) @db.Uuid()
  conditions                       PriceChangeCondition[] @default([PriceIncrease, PriceDecrease])
  delegate_aux_productSubscription ProductSubscription    @relation(fields: [id], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

/// @@delegate(notificationType)
model ProductNotification {
  id                                    String                    @id() @default(uuid()) @db.Uuid()
  createdAt                             DateTime                  @default(now())
  updatedAt                             DateTime                  @updatedAt()
  createdById                           String                    @db.Uuid()
  updatedById                           String                    @db.Uuid()
  createdBy                             User                      @relation("createdProductNotifications", fields: [createdById], references: [id])
  updatedBy                             User                      @relation("updatedProductNotifications", fields: [updatedById], references: [id])
  user                                  User                      @relation("notifications", fields: [userId], references: [id])
  userId                                String                    @db.Uuid()
  productRecordId                       String                    @db.Uuid()
  productRecord                         ProductRecord             @relation("notifications", fields: [productRecordId], references: [id])
  productId                             String                    @db.Uuid()
  product                               Product                   @relation("notifications", fields: [productId], references: [id])
  subscriptionId                        String?                   @db.Uuid()
  subscription                          ProductSubscription?      @relation("notifications", fields: [subscriptionId], references: [id], onDelete: SetNull)
  notificationType                      ProductNotificationType
  state                                 NotificationState
  stateAsOf                             DateTime
  failedAt                              DateTime?
  sentAt                                DateTime?
  mediums                               NotificationMedium[]      @default([Application])
  delegate_aux_priceChangeNotification  PriceChangeNotification?
  delegate_aux_statusChangeNotification StatusChangeNotification?
}

/// @@validate(previousPrice != newPrice, 'The previous and new prices for a notification must not be the same.')
model PriceChangeNotification {
  id                               String               @id() @default(uuid()) @db.Uuid()
  condition                        PriceChangeCondition
  previousPrice                    Float
  newPrice                         Float
  delegate_aux_productNotification ProductNotification  @relation(fields: [id], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

/// @@validate(previousStatus != newStatus, 'The previous and new statuses for a notification must not be the same.')
model StatusChangeNotification {
  id                               String              @id() @default(uuid()) @db.Uuid()
  previousStatus                   ProductStatus
  newStatus                        ProductStatus
  delegate_aux_productNotification ProductNotification @relation(fields: [id], references: [id], onDelete: Cascade, onUpdate: Cascade)
}
